./.git/hooks/fsmonitor-watchman.sample:75:	die "Watchman: command returned no output.\n" .
./.git/hooks/fsmonitor-watchman.sample:77:	die "Watchman: command returned invalid output: $response\n" .
./.git/hooks/pre-rebase.sample:6:# its job, and can prevent the command from running by exiting with
./.git/hooks/update.sample:34:	echo "Don't run this script from the command line." >&2
Binary file ./.git/index matches
./.git/logs/HEAD:112:64cc1a1dbd97b5c659bda03d1b1c33de6decb882 1e55882d1ed64624b2e1925c5245fbf0a1153dd1 Saladin Afoh <safoh@student.codam.nl> 1663660064 +0200	commit: Changed tokens list in command to char **
./.git/logs/refs/heads/saladin:24:64cc1a1dbd97b5c659bda03d1b1c33de6decb882 1e55882d1ed64624b2e1925c5245fbf0a1153dd1 Saladin Afoh <safoh@student.codam.nl> 1663660064 +0200	commit: Changed tokens list in command to char **
Binary file ./build/executor.o matches
Binary file ./build/parser.o matches
Binary file ./build/parser_test.o matches
./include/executor.h:18:# include <command.h>
./include/parser.h:19:# include <command.h>
Binary file ./mini_test matches
Binary file ./minishell matches
./README.md:21:- Display a prompt when waiting for a new command.
./README.md:33:- Implement pipes (| character). The output of each command in the pipeline is
./README.md:34:connected to the input of the next command via a pipe.
./src/executor.c:3:#include <command.h>
./src/executor.c:23:	t_command		*command;
./src/executor.c:27:	command = command_table->commands->content;
./src/executor.c:28:	execute(command->arguments, envp);
./src/minishell.c:5: * Abstract_syntax_tree gathers one or more command tables
./src/parser.c:1:#include "command.h"
./src/parser.c:40:void	fill_arguments(t_command *command, t_list **arguments)
./src/parser.c:43:	command->arguments = NULL;
./src/parser.c:44:	command->arguments = ft_calloc(command->arg_count + 1, sizeof(char *));
./src/parser.c:45:	if (!command->arguments)
./src/parser.c:50:		command->arguments[i] = (*arguments)->content;
./src/parser.c:58:	t_command *command;
./src/parser.c:62:	command = NULL;
./src/parser.c:63:	command = ft_calloc(1, sizeof(t_command));
./src/parser.c:64:	if (!command)
./src/parser.c:76:		command->arg_count++;
./src/parser.c:79:	fill_arguments(command, &arguments);
./src/parser.c:80:	return (command);
./src/parser.c:86:	t_list *command;
./src/parser.c:92:	command = NULL;
./src/parser.c:95:		command = ft_lstnew((void *)get_command(tokens));
./src/parser.c:96:		if (!command)
./src/parser.c:98:		ft_lstadd_back(&command_table->commands, command);
./unit_test/makerc/unit.mk:19:				../$(INCLUDE_DIR)/command.h \
./unit_test/src/parser_test.c:7:	t_command	*command;
./unit_test/src/parser_test.c:10:	command = NULL;
./unit_test/src/parser_test.c:14:	command = get_command(&tokens);
./unit_test/src/parser_test.c:17:		cr_expect(eq(str, command->arguments[i], expect[i]));
./unit_test/src/parser_test.c:20:	free(command->arguments);
./unit_test/src/parser_test.c:21:	free(command);
./unit_test/src/parser_test.c:28://	t_command	*command;
./unit_test/src/parser_test.c:33://	command = NULL;
./unit_test/src/parser_test.c:35://	command = get_command(&tokens);
./unit_test/src/parser_test.c:38://		token = command->redirs->content;	
./unit_test/src/parser_test.c:40://		command->redirs = command->redirs->next;
./unit_test/src/parser_test.c:43://	cr_assert(zero(ptr, command->redirs)); 
./unit_test/src/parser_test.c:44://	ft_lstclear(&command->redirs, free);
./unit_test/src/parser_test.c:45://	free(command);
